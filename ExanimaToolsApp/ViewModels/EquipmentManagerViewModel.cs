// IMPORTANT: Do not edit this file without first reading project-management/development_practices.md for ExanimaTools best practices.
// Ensure all logging uses injected ILoggingService.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Avalonia.Threading;
using ExanimaTools.Controls;
using ExanimaTools.Models;
using ExanimaTools.Persistence;
using System.IO;
using ExanimaTools.ViewModels;
using ExanimaToolsApp;
using System.ComponentModel;

namespace ExanimaTools.ViewModels
{
    public class EquipmentManagerViewModel : INotifyPropertyChanged
    {
        private readonly ILoggingService? _logger;
        private readonly EquipmentRepository _equipmentRepository;
        private const string DefaultDbFile = "exanima_tools.db";

        // Command properties
        public ICommand AddEquipmentCommand { get; }
        public ICommand RemoveEquipmentCommand { get; }
        public ICommand EditEquipmentCommand { get; }
        public ICommand ShowAddWeaponFormCommand { get; }
        public ICommand ShowAddArmourFormCommand { get; }
        public ICommand SaveNewEquipmentCommand { get; }
        public ICommand AddStatCommand { get; }
        public ICommand EditEquipmentFromTreeCommand { get; }

        public EquipmentManagerViewModel(ILoggingService? logger = null)
        {
            _logger = logger;
            _logger?.LogOperation("EquipmentManagerViewModel", "Created");
            NewEquipment = new EquipmentPiece(_logger);
            NewEquipment.Rank = Rank.Inept;
            var dbPath = DbManager.GetDbPath();
            _equipmentRepository = new EquipmentRepository($"Data Source={dbPath}", _logger);
            // Ensure dropdowns are always initialized
            addFormMode = AddFormMode.Weapon;
            SetCategoryOptionsForMode();
            // Set initial stat types after NewEquipment is set
            SyncStatPipViewModels();
            if (AvailableStatTypes.Count > 0)
                SelectedStatType = AvailableStatTypes[0];
            _ = LoadEquipmentAsync();
            AddEquipmentCommand = new AsyncRelayCommand(() => AddEquipmentAsync(NewEquipment));
            RemoveEquipmentCommand = new AsyncRelayCommand(RemoveEquipmentAsync, CanRemoveEquipment);
            EditEquipmentCommand = new AsyncRelayCommand(() =>
            {
                var oldEq = SelectedEquipment ?? new EquipmentPiece(_logger);
                var updatedEq = NewEquipment ?? new EquipmentPiece(_logger);
                return EditEquipmentAsync((oldEq, updatedEq));
            });
            ShowAddWeaponFormCommand = new RelayCommand(ShowAddWeaponForm);
            ShowAddArmourFormCommand = new RelayCommand(ShowAddArmourForm);
            SaveNewEquipmentCommand = new AsyncRelayCommand(SaveNewEquipment);
            AddStatCommand = new RelayCommand(AddStat);
            EditEquipmentFromTreeCommand = new RelayCommand(() => EditEquipmentFromTree(SelectedEquipment));
        }
        // Observable collection of equipment pieces for binding
        private ObservableCollection<EquipmentPiece> equipmentList = new();
        public ObservableCollection<EquipmentPiece> EquipmentList
        {
            get => equipmentList;
            set { if (equipmentList != value) { equipmentList = value; OnPropertyChanged(nameof(EquipmentList)); } }
        }
        private EquipmentPiece? selectedEquipment;
        public EquipmentPiece? SelectedEquipment
        {
            get => selectedEquipment;
            set { if (selectedEquipment != value) { selectedEquipment = value; OnPropertyChanged(nameof(SelectedEquipment)); } }
        }
        private string? errorMessage;
        public string? ErrorMessage
        {
            get => errorMessage;
            set { if (errorMessage != value) { errorMessage = value; OnPropertyChanged(nameof(ErrorMessage)); } }
        }
        private string? confirmationMessage;
        public string? ConfirmationMessage
        {
            get => confirmationMessage;
            set { if (confirmationMessage != value) { confirmationMessage = value; OnPropertyChanged(nameof(ConfirmationMessage)); } }
        }
        private EquipmentPiece newEquipment = new EquipmentPiece();
        public EquipmentPiece NewEquipment
        {
            get => newEquipment;
            set {
                if (newEquipment != value) {
                    newEquipment = value;
                    _logger?.LogOperation("EquipmentManagerViewModel.NewEquipmentSet", $"Instance: {newEquipment.GetHashCode()}, Stats ref: {newEquipment.Stats.GetHashCode()}, Stats count: {newEquipment.Stats.Count}");
                    OnPropertyChanged(nameof(NewEquipment));
                    SyncStatPipViewModels(); // Always update pip stats when equipment changes
                }
            }
        }
        private string newStatInput = string.Empty;
        public string NewStatInput
        {
            get => newStatInput;
            set { if (newStatInput != value) { newStatInput = value; OnPropertyChanged(nameof(NewStatInput)); } }
        }
        private bool isAddFormVisible;
        public bool IsAddFormVisible
        {
            get => isAddFormVisible;
            set { if (isAddFormVisible != value) { isAddFormVisible = value; OnPropertyChanged(nameof(IsAddFormVisible)); } }
        }
        private bool isEditMode;
        public bool IsEditMode
        {
            get => isEditMode;
            set { if (isEditMode != value) { isEditMode = value; OnPropertyChanged(nameof(IsEditMode)); } }
        }
        public ObservableCollection<StatType> AvailableStatTypes { get; } = new();
        private StatType? selectedStatType;
        public StatType? SelectedStatType
        {
            get => selectedStatType;
            set { if (!EqualityComparer<StatType?>.Default.Equals(selectedStatType, value)) { selectedStatType = value; OnPropertyChanged(nameof(SelectedStatType)); } }
        }
        public ObservableCollection<EquipmentType> EquipmentTypes { get; } = new(Enum.GetValues(typeof(EquipmentType)).Cast<EquipmentType>());
        public ObservableCollection<EquipmentSlot> EquipmentSlots { get; } = new(Enum.GetValues(typeof(EquipmentSlot)).Cast<EquipmentSlot>());
        public ObservableCollection<ArmourLayer> ArmourLayers { get; } = new(Enum.GetValues(typeof(ArmourLayer)).Cast<ArmourLayer>());
        public ObservableCollection<StatPipViewModel> NewEquipmentStatPips { get; } = new();
        public Array EquipmentQualities => Enum.GetValues(typeof(ExanimaTools.Models.EquipmentQuality));
        public Array EquipmentConditions => Enum.GetValues(typeof(ExanimaTools.Models.EquipmentCondition));
        public Array AllRanks => Enum.GetValues(typeof(Rank));
        public static readonly Dictionary<string, List<string>> WeaponCategorySubcategoryMap = new()
        {
            ["Sword"] = new List<string> { "Longsword", "Shortsword", "Greatsword", "Arming Sword" },
            ["Axe"] = new List<string> { "Battleaxe", "Handaxe", "Greataxe" },
            ["Polearm"] = new List<string> { "Spear", "Halberd", "Glaive" },
            ["Bludgeon"] = new List<string> { "Mace", "Hammer", "Club" },
            ["Dagger"] = new List<string> { "Stiletto", "Dirk", "Main Gauche" },
            ["Shield"] = new List<string> { "Buckler", "Round", "Kite", "Tower" },
            ["Unconventional"] = new List<string> { "Improvised", "Exotic" }
        };
        public static readonly Dictionary<string, List<string>> ArmourCategorySubcategoryMap = new()
        {
            ["Head"] = new List<string> { "Cap", "Hood", "Hat", "Arming Cap", "Padded Cap", "Coif", "Plate Helm", "Bascinet", "Sallet", "Barbute", "Great Helm" },
            ["Body"] = new List<string> { "Shirt", "Tunic", "Tabard", "Doublet", "Jerkin", "Vest", "Gambeson", "Padded Gambeson", "Arming Doublet", "Mail Shirt", "Hauberk", "Haubergeon", "Leather Cuirass", "Splint Cuirass", "Brigandine", "Lamellar", "Scale", "Coat of Plates", "Plate Cuirass", "Breastplate", "Full Plate Armour" },
            ["Shoulders"] = new List<string> { "Padded Spaulders", "Mail Shoulders", "Leather Spaulders", "Splint Spaulders", "Plate Spaulders", "Pauldrons" },
            ["Elbows"] = new List<string> { "Padded Couters", "Leather Couters", "Splint Couters", "Plate Couters" },
            ["Wrists"] = new List<string> { "Padded Bracers", "Mail Bracers", "Leather Bracers", "Splint Bracers", "Vambraces", "Plate Bracers", "Plate Vambraces" },
            ["Hands"] = new List<string> { "Gloves", "Padded Gloves", "Mail Gauntlets", "Leather Gauntlets", "Plate Gauntlets" },
            ["Legs"] = new List<string> { "Trousers", "Pants", "Leggings", "Padded Leggings", "Mail Leggings", "Chausses", "Leather Cuisses", "Splint Cuisses", "Greaves", "Plate Cuisses", "Plate Greaves", "Plate Leggings" },
            ["Feet"] = new List<string> { "Shoes", "Boots", "Sandals", "Padded Shoes", "Padded Boots", "Mail Shoes", "Plate Sabatons" }
        };
        private string selectedCategory = string.Empty;
        public string SelectedCategory
        {
            get => selectedCategory;
            set
            {
                if (selectedCategory != value)
                {
                    selectedCategory = value;
                    OnPropertyChanged(nameof(SelectedCategory));
                    SubcategoryOptions.Clear();
                    if (addFormMode == AddFormMode.Weapon && !string.IsNullOrEmpty(value) && WeaponCategorySubcategoryMap.TryGetValue(value, out var subs))
                    {
                        foreach (var sub in subs)
                            SubcategoryOptions.Add(sub);
                        SelectedSubcategory = SubcategoryOptions.FirstOrDefault() ?? string.Empty;
                    }
                    else if (addFormMode == AddFormMode.Armour && !string.IsNullOrEmpty(value) && ArmourCategorySubcategoryMap.TryGetValue(value, out var subs2))
                    {
                        foreach (var sub in subs2)
                            SubcategoryOptions.Add(sub);
                        SelectedSubcategory = SubcategoryOptions.FirstOrDefault() ?? string.Empty;
                    }
                    else
                    {
                        SelectedSubcategory = string.Empty;
                    }
                    NewEquipment.Category = value;
                    NewEquipment.Subcategory = SelectedSubcategory;
                }
            }
        }
        private string selectedSubcategory = string.Empty;
        public string SelectedSubcategory
        {
            get => selectedSubcategory;
            set
            {
                if (selectedSubcategory != value)
                {
                    selectedSubcategory = value;
                    OnPropertyChanged(nameof(SelectedSubcategory));
                    NewEquipment.Subcategory = value;
                }
            }
        }
        public ObservableCollection<string> CategoryOptions { get; } = new();
        public ObservableCollection<string> SubcategoryOptions { get; } = new();
        private enum AddFormMode { None, Weapon, Armour }
        private AddFormMode addFormMode = AddFormMode.None;

        private void SetCategoryOptionsForMode()
        {
            CategoryOptions.Clear();
            SubcategoryOptions.Clear();
            OnPropertyChanged(nameof(CategoryOptions)); // Notify collection changed
            OnPropertyChanged(nameof(SubcategoryOptions));
            if (addFormMode == AddFormMode.Weapon)
            {
                foreach (var cat in WeaponCategorySubcategoryMap.Keys)
                    CategoryOptions.Add(cat);
                OnPropertyChanged(nameof(CategoryOptions));
                if (CategoryOptions.Count > 0)
                    SelectedCategory = CategoryOptions[0];
                else
                    SelectedCategory = string.Empty;
                if (!string.IsNullOrEmpty(SelectedCategory) && WeaponCategorySubcategoryMap.TryGetValue(SelectedCategory, out var subs))
                {
                    foreach (var sub in subs)
                        SubcategoryOptions.Add(sub);
                }
                OnPropertyChanged(nameof(SubcategoryOptions));
                if (SubcategoryOptions.Count > 0)
                    SelectedSubcategory = SubcategoryOptions[0];
                else
                    SelectedSubcategory = string.Empty;
            }
            else if (addFormMode == AddFormMode.Armour)
            {
                foreach (var cat in ArmourCategorySubcategoryMap.Keys)
                    CategoryOptions.Add(cat);
                OnPropertyChanged(nameof(CategoryOptions));
                if (CategoryOptions.Count > 0)
                    SelectedCategory = CategoryOptions[0];
                else
                    SelectedCategory = string.Empty;
                if (!string.IsNullOrEmpty(SelectedCategory) && ArmourCategorySubcategoryMap.TryGetValue(SelectedCategory, out var subs))
                {
                    foreach (var sub in subs)
                        SubcategoryOptions.Add(sub);
                }
                OnPropertyChanged(nameof(SubcategoryOptions));
                if (SubcategoryOptions.Count > 0)
                    SelectedSubcategory = SubcategoryOptions[0];
                else
                    SelectedSubcategory = string.Empty;
            }
            // Always notify after setting
            OnPropertyChanged(nameof(SelectedCategory));
            OnPropertyChanged(nameof(SelectedSubcategory));
        }

        // Async stub for loading equipment (for future persistence)
        public async Task LoadEquipmentAsync()
        {
            try
            {
                var loaded = await _equipmentRepository.GetAllAsync();
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    EquipmentList.Clear();
                    foreach (var eq in loaded)
                        EquipmentList.Add(eq);
                    BuildEquipmentTree(); // Ensure tree is built after loading
                    ConfirmationMessage = $"Loaded {loaded.Count} equipment from database.";
                    ErrorMessage = null;
                });
            }
            catch (Exception ex)
            {
                ErrorMessage = $"Failed to load equipment: {ex.Message}\n{ex.StackTrace}";
                _logger?.LogError($"Failed to load equipment: {ex.Message}", ex);
            }
        }

        // Async stub for saving equipment (for future persistence)
        public async Task SaveEquipmentAsync()
        {
            // TODO: Save to storage
            await Task.CompletedTask;
        }

        // Validation logic for equipment
        private bool ValidateEquipment(EquipmentPiece equipment, out string? error)
        {
            if (string.IsNullOrWhiteSpace(equipment.Name))
            {
                error = "Equipment name is required.";
                return false;
            }
            if (EquipmentList.Any(e => e != equipment && e.Name == equipment.Name))
            {
                error = $"An equipment named '{equipment.Name}' already exists.";
                return false;
            }
            // Prevent subcategory from being the same as category
            if (!string.IsNullOrEmpty(equipment.Category) && equipment.Category == equipment.Subcategory)
            {
                error = "Subcategory must not be the same as category. Please select a specific subcategory.";
                return false;
            }
            error = null;
            return true;
        }

        // Async command to add new equipment
        private async Task AddEquipmentAsync(EquipmentPiece newEquipment)
        {
            _logger?.LogOperation("AddEquipmentAsync", newEquipment?.Name);
            if (newEquipment == null)
                return;
            if (!ValidateEquipment(newEquipment, out var error))
            {
                ErrorMessage = error;
                ConfirmationMessage = null;
                return;
            }
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                EquipmentList.Add(newEquipment);
                ConfirmationMessage = $"Added '{newEquipment.Name}'.";
                ErrorMessage = null;
            });
        }

        // Async command to remove selected equipment
        private async Task RemoveEquipmentAsync()
        {
            _logger?.LogOperation("RemoveEquipmentAsync", SelectedEquipment?.Name);
            if (SelectedEquipment != null)
            {
                var toRemove = SelectedEquipment;
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    EquipmentList.Remove(toRemove);
                    SelectedEquipment = null;
                    ConfirmationMessage = $"Removed '{toRemove.Name}'.";
                    ErrorMessage = null;
                    _logger?.LogOperation("RemoveEquipmentAsync", $"Removed: {toRemove.Name}");
                });
            }
        }

        private bool CanRemoveEquipment() => SelectedEquipment != null;

        // Async command to edit equipment (replace with updated instance)
        private async Task EditEquipmentAsync((EquipmentPiece Old, EquipmentPiece Updated) edit)
        {
            _logger?.LogOperation("EditEquipmentAsync", $"{edit.Old?.Name} -> {edit.Updated?.Name}");
            var (oldEq, updatedEq) = edit;
            if (oldEq == null || updatedEq == null)
                return;
            if (!ValidateEquipment(updatedEq, out var error))
            {
                ErrorMessage = error;
                ConfirmationMessage = null;
                return;
            }
            int idx = EquipmentList.IndexOf(oldEq);
            if (idx >= 0)
            {
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    EquipmentList[idx] = updatedEq;
                    SelectedEquipment = updatedEq;
                    ConfirmationMessage = $"Updated '{updatedEq.Name}'.";
                    ErrorMessage = null;
                });
            }
        }

        private void SyncStatPipViewModels()
        {
            var statsList = (NewEquipment?.Stats != null) ? string.Join(", ", NewEquipment.Stats.Select(kv => $"{kv.Key}={kv.Value}")) : "<null>";
            _logger?.LogOperation("SyncStatPipViewModels", $"Called for: {NewEquipment?.Name}, Stats: {statsList}, Stats ref: {NewEquipment?.Stats.GetHashCode()}, Stats count: {NewEquipment?.Stats.Count}" );
            NewEquipmentStatPips.Clear();
            int pipCount = 0;
            if (NewEquipment?.Stats != null)
            {
                foreach (var kvp in NewEquipment.Stats)
                {
                    if (kvp.Key == StatType.Weight) continue; // Remove Weight from pip stats
                    var pipVm = new StatPipViewModel(kvp.Key, kvp.Value, v => NewEquipment.SetStat(kvp.Key, v), _logger);
                    NewEquipmentStatPips.Add(pipVm);
                    pipCount++;
                }
            }
            _logger?.LogOperation("SyncStatPipViewModels", $"Pip stats added: {pipCount}, Pip VMs: [{string.Join(", ", NewEquipmentStatPips.Select(p => p.StatLabel + "=" + p.Value))}]");
            UpdateAvailableStatTypes();
            OnPropertyChanged(nameof(NewEquipmentStatPips)); // Notify collection changed
            OnPropertyChanged(nameof(AvailableStatTypes));
        }
        private void UpdateAvailableStatTypes()
        {
            AvailableStatTypes.Clear();
            IEnumerable<StatType> allowed = NewEquipment.Type switch
            {
                EquipmentType.Weapon => WeaponOptionalStats,
                EquipmentType.Armour => ArmourOptionalStats,
                _ => Array.Empty<StatType>()
            };
            foreach (var stat in allowed.Except(NewEquipment.Stats.Keys))
                AvailableStatTypes.Add(stat);
            if (AvailableStatTypes.Count > 0)
                SelectedStatType = AvailableStatTypes[0];
            else
                SelectedStatType = null;
        }

        private static readonly StatType[] WeaponStats = new[]
        {
            StatType.Encumbrance
        };
        private static readonly StatType[] WeaponOptionalStats = new[]
        {
            StatType.Balance,
            StatType.Impact,
            StatType.Slash,
            StatType.Crush,
            StatType.Pierce,
            StatType.Thrust,
            StatType.Points // Allow Points as an optional pip stat
        };
        private static readonly StatType[] ArmourStats = new[]
        {
            StatType.ImpactResistance,
            StatType.Encumbrance,
            StatType.Coverage
        };
        private static readonly StatType[] ArmourOptionalStats = new[]
        {
            StatType.SlashProtection,
            StatType.CrushProtection,
            StatType.PierceProtection,
            StatType.Points // Allow Points as an optional pip stat
        };

        private void ShowAddWeaponForm()
        {
            _logger?.LogOperation("ShowAddWeaponForm", "User opened Add Weapon form");
            addFormMode = AddFormMode.Weapon;
            SetCategoryOptionsForMode();
            SelectedCategory = CategoryOptions.FirstOrDefault() ?? string.Empty;
            SelectedSubcategory = SubcategoryOptions.FirstOrDefault() ?? string.Empty;
            NewEquipment = new EquipmentPiece(_logger!)
            {
                Type = EquipmentType.Weapon,
                Slot = EquipmentSlot.Hands, // Default for weapon
                Layer = null,
                Stats = WeaponStats.ToDictionary(st => st, st => 0.5f),
                Category = SelectedCategory,
                Subcategory = SelectedSubcategory,
                Rank = Rank.Inept // Explicitly set default rank
            };
            IsAddFormVisible = true;
            SyncStatPipViewModels();
        }

        private void ShowAddArmourForm()
        {
            _logger?.LogOperation("ShowAddArmourForm", "User opened Add Armour form");
            addFormMode = AddFormMode.Armour;
            SetCategoryOptionsForMode();
            SelectedCategory = CategoryOptions.FirstOrDefault() ?? string.Empty;
            SelectedSubcategory = SubcategoryOptions.FirstOrDefault() ?? string.Empty;
            NewEquipment = new EquipmentPiece(_logger!)
            {
                Type = EquipmentType.Armour,
                Slot = EquipmentSlot.Body, // Default for armour
                Layer = ArmourLayer.Padding,
                Stats = ArmourStats.ToDictionary(st => st, st => 0.5f),
                Category = SelectedCategory,
                Subcategory = SelectedSubcategory,
                Rank = Rank.Inept // Explicitly set default rank
            };
            IsAddFormVisible = true;
            SyncStatPipViewModels();
        }

        private async Task SaveNewEquipment()
        {
            _logger?.LogOperation("SaveNewEquipment", $"User saving equipment: {NewEquipment.Name}");
            if (!ValidateEquipment(NewEquipment, out var error))
            {
                ErrorMessage = error;
                ConfirmationMessage = null;
                _logger?.LogError($"Validation failed: {error}");
                return;
            }
            if (IsEditMode)
            {
                // Use Id to find and update the correct item
                var idx = EquipmentList.ToList().FindIndex(e => e.Id == NewEquipment.Id);
                if (idx >= 0)
                {
                    var updated = new EquipmentPiece(_logger!)
                    {
                        Id = NewEquipment.Id,
                        Name = NewEquipment.Name,
                        Type = NewEquipment.Type,
                        Slot = NewEquipment.Slot,
                        Layer = NewEquipment.Layer,
                        Stats = new Dictionary<StatType, float>(NewEquipment.Stats),
                        Description = NewEquipment.Description,
                        Quality = NewEquipment.Quality,
                        Condition = NewEquipment.Condition,
                        Category = NewEquipment.Category,
                        Subcategory = NewEquipment.Subcategory,
                        Rank = NewEquipment.Rank,
                        Points = NewEquipment.Points,
                        Weight = NewEquipment.Weight
                    };
                    try
                    {
                        await _equipmentRepository.UpdateAsync(updated);
                        EquipmentList[idx] = updated;
                        BuildEquipmentTree();
                        ConfirmationMessage = $"Updated '{updated.Name}'.";
                        ErrorMessage = null;
                        NewEquipment = new EquipmentPiece();
                        IsAddFormVisible = false;
                        IsEditMode = false;
                        SelectedEquipment = null;
                        _logger?.LogOperation("SaveNewEquipment", $"Updated equipment: {updated.Name}");
                    }
                    catch (Exception ex)
                    {
                        ErrorMessage = $"Failed to update equipment: {ex.Message}";
                        _logger?.LogError($"Failed to update equipment: {ex.Message}", ex);
                    }
                    return;
                }
            }
            // Otherwise, add as new
            var eq = new EquipmentPiece(_logger!)
            {
                Name = NewEquipment.Name,
                Type = NewEquipment.Type,
                Slot = NewEquipment.Slot,
                Layer = NewEquipment.Layer,
                Stats = new Dictionary<StatType, float>(NewEquipment.Stats),
                Description = NewEquipment.Description,
                Quality = NewEquipment.Quality,
                Condition = NewEquipment.Condition,
                Category = NewEquipment.Category,
                Subcategory = NewEquipment.Subcategory,
                Rank = NewEquipment.Rank,
                Points = NewEquipment.Points,
                Weight = NewEquipment.Weight
            };
            try
            {
                await _equipmentRepository.AddAsync(eq);
                EquipmentList.Add(eq);
                BuildEquipmentTree();
                ConfirmationMessage = $"Saved '{eq.Name}'.";
                ErrorMessage = null;
                NewEquipment = new EquipmentPiece();
                _logger?.LogOperation("SaveNewEquipment", $"Added new equipment: {eq.Name}");
            }
            catch (Exception ex)
            {
                ErrorMessage = $"Failed to save equipment: {ex.Message}";
                _logger?.LogError($"Failed to save equipment: {ex.Message}", ex);
            }
        }

        private void AddStat()
        {
            if (SelectedStatType is StatType statType && !NewEquipment.Stats.ContainsKey(statType))
            {
                NewEquipment.Stats[statType] = 0.5f;
                SyncStatPipViewModels();
                _logger?.LogOperation("AddStat", $"Added stat: {statType}");
            }
        }

        public void EditEquipmentFromTree(EquipmentPiece? equipment)
        {
            if (equipment == null) return;
            _logger?.LogOperation("EditEquipmentFromTree", $"User editing: {equipment.Name}");
            // Set up the add/edit form with the selected equipment's data
            NewEquipment = new EquipmentPiece(_logger!)
            {
                Id = equipment.Id,
                Name = equipment.Name,
                Type = equipment.Type,
                Slot = equipment.Slot,
                Layer = equipment.Layer,
                Stats = new Dictionary<StatType, float>(equipment.Stats),
                Description = equipment.Description,
                Quality = equipment.Quality,
                Condition = equipment.Condition,
                Category = equipment.Category,
                Subcategory = equipment.Subcategory,
                Rank = equipment.Rank,
                Points = equipment.Points,
                Weight = equipment.Weight
            };
            // Repopulate category and subcategory options for the correct mode
            addFormMode = equipment.Type == EquipmentType.Weapon ? AddFormMode.Weapon : AddFormMode.Armour;
            SetCategoryOptionsForMode();
            // Now set the selected values after options are filled
            if (!string.IsNullOrEmpty(equipment.Category) && CategoryOptions.Contains(equipment.Category))
                SelectedCategory = equipment.Category;
            else if (CategoryOptions.Count > 0)
                SelectedCategory = CategoryOptions[0];
            if (!string.IsNullOrEmpty(equipment.Subcategory) && SubcategoryOptions.Contains(equipment.Subcategory))
                SelectedSubcategory = equipment.Subcategory;
            else if (SubcategoryOptions.Count > 0)
                SelectedSubcategory = SubcategoryOptions[0];
            IsAddFormVisible = true;
            IsEditMode = true;
            SyncStatPipViewModels();
        }

        private string searchText = string.Empty;
        public string SearchText
        {
            get => searchText;
            set { if (searchText != value) { searchText = value; OnPropertyChanged(nameof(SearchText)); BuildEquipmentTree(); } }
        }

        private IEnumerable<EquipmentPiece> GetFilteredEquipment()
        {
            if (string.IsNullOrWhiteSpace(SearchText))
                return EquipmentList;
            var lower = SearchText.ToLowerInvariant();
            return EquipmentList.Where(eq =>
                (!string.IsNullOrEmpty(eq.Name) && eq.Name.ToLowerInvariant().Contains(lower)) ||
                (!string.IsNullOrEmpty(eq.Category) && eq.Category.ToLowerInvariant().Contains(lower)) ||
                (!string.IsNullOrEmpty(eq.Subcategory) && eq.Subcategory.ToLowerInvariant().Contains(lower)) ||
                (!string.IsNullOrEmpty(eq.Description) && eq.Description.ToLowerInvariant().Contains(lower))
            );
        }

        // Tree for equipment browser
        public ObservableCollection<EquipmentTreeNodeViewModel> EquipmentTree { get; } = new();
        private EquipmentTreeNodeViewModel? selectedEquipmentTreeItem;
        public EquipmentTreeNodeViewModel? SelectedEquipmentTreeItem
        {
            get => selectedEquipmentTreeItem;
            set { if (selectedEquipmentTreeItem != value) { selectedEquipmentTreeItem = value; OnPropertyChanged(nameof(SelectedEquipmentTreeItem)); } }
        }

        private void BuildEquipmentTree()
        {
            EquipmentTree.Clear();
            var filtered = GetFilteredEquipment();
            var byType = filtered.GroupBy(e => e.Type);
            foreach (var typeGroup in byType)
            {
                var typeNode = new EquipmentTreeNodeViewModel(typeGroup.Key.ToString());
                var byCategory = typeGroup.GroupBy(e => e.Category);
                foreach (var catGroup in byCategory)
                {
                    var catNode = new EquipmentTreeNodeViewModel(catGroup.Key);
                    var bySubcat = catGroup.GroupBy(e => e.Subcategory);
                    foreach (var subGroup in bySubcat)
                    {
                        if (subGroup.Count() == 1 && subGroup.Key == subGroup.First().Name)
                        {
                            catNode.Children.Add(new EquipmentTreeNodeViewModel(subGroup.First()));
                        }
                        else
                        {
                            var subNode = new EquipmentTreeNodeViewModel(subGroup.Key);
                            foreach (var eq in subGroup)
                                subNode.Children.Add(new EquipmentTreeNodeViewModel(eq));
                            catNode.Children.Add(subNode);
                        }
                    }
                    typeNode.Children.Add(catNode);
                }
                EquipmentTree.Add(typeNode);
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged(string propertyName) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
